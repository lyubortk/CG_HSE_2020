// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ComputeHarmonics

#define PI            3.14159265359f
#define TWO_PI        6.28318530718f
#define FOUR_PI       12.56637061436f
#define INV_PI        0.31830988618f
#define INV_TWO_PI    0.15915494309f
#define INV_FOUR_PI   0.07957747155f
#define HALF_PI       1.57079632679f
#define INV_HALF_PI   0.636619772367f

#define SQRT_PI       1.77245385091f

RWStructuredBuffer<float4> SH_0_1_r;
RWStructuredBuffer<float4> SH_0_1_g;
RWStructuredBuffer<float4> SH_0_1_b;

RWStructuredBuffer<float4> SH_2_r;
RWStructuredBuffer<float4> SH_2_g;
RWStructuredBuffer<float4> SH_2_b;

RWStructuredBuffer<float4> SH_2_rgb;

TextureCube<half4> _Env;
SamplerState samplerLinearRepeat;

uint Hash(uint s)
{
    s ^= 2747636419u;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    return s;
}

float Random(uint seed)
{
    return float(Hash(seed)) / 4294967295.0; // 2^32-1
}

float3 SampleColor(float3 direction)
{   
    float4 tex = _Env.SampleLevel(samplerLinearRepeat, direction, 0);
    return tex.rgb;
}

float HarmonicFunction(int l, int m, float3 w)
{
    if (l == 0) {
        return 1 / (2 * SQRT_PI);
    }

    if (l == 1) {
        if (m == -1) {
            return -sqrt(3) * w.y / (2 * SQRT_PI);
        }
        if (m == 0) {
            return sqrt(3) * w.z / (2 * SQRT_PI);
        }
        if (m == 1) {
            return -sqrt(3) * w.x / (2 * SQRT_PI);
        }
    }

    if (l == 2) {
        if (m == -2) {
            return sqrt(15) * w.y * w.x / (2 * SQRT_PI);
        }
        if (m == -1) {
            return -sqrt(15) * w.y * w.z / (2 * SQRT_PI);
        }
        if (m == 0) {
            return sqrt(5) * (3 * w.z * w.z - 1) / (4 * SQRT_PI);
        }
        if (m == 1) {
            return -sqrt(15) * w.x * w.z / (2 * SQRT_PI);
        }
        if (m == 2) {
            return sqrt(15) * (w.x * w.x - w.y * w.y) / (4 * SQRT_PI);
        }
    }
    return 0;
}

float HarmonicFunctionCoefficients(int l, int m) {
    if (l == 2 && m == 0) {
        return sqrt(5) / (4 * SQRT_PI);
    }
    if (l == 2 && m == 2) {
        return sqrt(15) / (4 * SQRT_PI);
    }
    return HarmonicFunction(l, m, float3(1, 1, 1));
}

[numthreads(1024, 1, 1)]
void ComputeHarmonics(uint id : SV_DispatchThreadID)
{
    const int THREADS = 1024;
    const int SAMPLES = 200;
    
    float C[3] = {PI, TWO_PI / 3, PI / 4};

    // Populate results buffer using monte-carlo method.
    // You can see the Random(i) function. Use it just as with the previous task.
    
    // TASK: project light from _Env to spherical harmonic coefficients and store them in results[]
    
    float3 integral[3][5];
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 5; j++) {
            integral[i][j] = float3(0, 0, 0);
        }
    }

    for (int i = 0; i < SAMPLES; i++) {
        float cosPhi = Random(i * 2) * 2 - 1;
        float theta = Random(i * 2 + 1) * 2 * PI;
        float sinPhi = sqrt(1 - cosPhi * cosPhi);
        float3 lightDir = float3(sinPhi * cos(theta), sinPhi * sin(theta), cosPhi);
        float3 color = SampleColor(lightDir);

        for (int l = 0; l <= 2; l++) {
            for (int m = -l; m <= l; m++) {
                integral[l][m + l] += HarmonicFunction(l, m, lightDir) * color;
            }
        }
    }

    for (int l = 0; l < 3; l++) {
        for (int m = -l; m <= l; m++) {
            integral[l][m + l] *= 1.0 / SAMPLES * 4;
            integral[l][m + l] *= C[l];
            integral[l][m + l] *= HarmonicFunctionCoefficients(l, m);
        }
    }

    SH_0_1_r[id] = float4(integral[1][2].x, integral[1][0].x, integral[1][1].x, integral[0][0].x);
    SH_0_1_g[id] = float4(integral[1][2].y, integral[1][0].y, integral[1][1].y, integral[0][0].y);
    SH_0_1_b[id] = float4(integral[1][2].z, integral[1][0].z, integral[1][1].z, integral[0][0].z);
    
    SH_2_r[id] = float4(integral[2][0].x, integral[2][1].x, integral[2][3].x, integral[2][2].x);
    SH_2_g[id] = float4(integral[2][0].y, integral[2][1].y, integral[2][3].y, integral[2][2].y);
    SH_2_b[id] = float4(integral[2][0].z, integral[2][1].z, integral[2][3].z, integral[2][2].z);    
    
    SH_2_rgb[id] = float4(integral[2][4].x, integral[2][4].y, integral[2][4].z, 0);
}
